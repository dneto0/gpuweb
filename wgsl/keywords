#!/usr/bin/env perl

# A script to print the contents of a grammar rule for a list
# of reserved words.

# C++ keywords
# Extracted from working draft at https://eel.is/c++draft/ 
#  https://eel.is/c++draft/gram.lex#nt:keyword
#   "Any identifier listed in Table 5" plus import, module, export
#        https://eel.is/c++draft/tab:lex.key
#

my  @cpp = qw(
export
import
module

alignas
alignof
asm
auto
bool
break
case
catch
char
char16_t
char32_t
char8_t
class
co_await
co_return
co_yield
concept
const
const_cast
consteval
constexpr
constinit
continue
decltype
default
delete
do
double
dynamic_cast
else
enum
explicit
export
extern
false
float
for
friend
goto
if
inline
int
long
mutable
namespace
new
noexcept
nullptr
operator
private
protected
public
register
reinterpret_cast
requires
return
short
signed
sizeof
static
static_assert
static_cast
struct
switch
template
this
thread_local
throw
true
try
typedef
typeid
typename
union
unsigned
using
virtual
void
volatile
wchar_t
while
);

# Rust
# https://doc.rust-lang.org/reference/keywords.html#reserved-keywords
# We include strict, reserved, and weak
# Excludes 'strict because it starts with a single quote.

my @rust = qw(
  as
  break
  const
  continue
  crate
  else
  enum
  extern
  false
  fn
  for
  if
  impl
  in
  let
  loop
  match
  mod
  move
  mut
  pub
  ref
  return
  self
  Self
  static
  struct
  super
  trait
  true
  type
  unsafe
  use
  where
  while

  abstract
  become
  box
  do
  final
  macro
  override
  priv
  typeof
  unsized
  virtual
  yield

  macro_rules
  union
);


my @smalltalk = qw(
  nil
  self
  super
  true
  false );



# ECMAScript
#  https://262.ecma-international.org/5.1/#sec-7.6.1.1 
# Keywords, Reserved, FutureReserved

my @ecmascript = qw(
    break
    case
    catch
    continue
    debugger
    default
    delete
    do
    else
    finally
    for
    function
    if
    in
    instanceof
    new
    return
    switch
    this
    throw
    try
    typeof
    var
    void
    while
    with


class
const
enum
export
extends
import
super


implements
interface
let
package
private
protected
public
static
yield

);


# Already in use by WGSL
my @wgsl = qw(
array
atomic
bitcast
bool
break
case
continue
continuing
default
discard
else
enable
f32
fallthrough
false
fn
for
function
i32
if
let
loop
mat2x2
mat2x3
mat2x4
mat3x2
mat3x3
mat3x4
mat4x2
mat4x3
mat4x4
override
private
ptr
return
sampler
sampler_comparison
storage
struct
switch
texture_1d
texture_2d
texture_2d_array
texture_3d
texture_cube
texture_cube_array
texture_depth_2d
texture_depth_2d_array
texture_depth_cube
texture_depth_cube_array
texture_depth_multisampled_2d
texture_multisampled_2d
texture_storage_1d
texture_storage_2d
texture_storage_2d_array
texture_storage_3d
true
type
u32
uniform
var
vec2
vec3
vec4
while
workgroup
);


# Already reserved by WGSL
@wgsl_reserved = qw(
asm
bf16
const
demote
demote_to_helper
do
enum
f16
f64
handle
i16
i64
i8
mat
premerge
regardless
std
typedef
u16
u64
u8
unless
using
vec
void
wgsl
);


# Key is a keyword.
# Value is a list of non-WGSL languages that reserve the word in some way.
# The value can be empty, when only WGSL reserves the word.
my %words = ();

# Adds a list of keywords, from a given language.
# $lang should be empty when the given language is WGSL.
sub add_from($@) {
  my ($lang, @keywords) = @_;
  foreach my $word (@keywords) {
    if (defined $words{$word} && $lang) {
      push @{$words{$word}}, $lang;
    } else {
      $words{$word} = ($lang ? [$lang] : []);
    }
  }
}

add_from('C++', @cpp);
add_from('ECMAScript', @ecmascript);
add_from('Rust', @rust);
add_from('Smalltalk', @smalltalk);
add_from('', @wgsl_reserved);

# Remove keywords already used in WGSL.
foreach my $word (@wgsl) { 
  delete $words{$word};
}

# Print the contents of the _reserved grammar rule.
foreach my $word (sort {$a cmp $b} keys %words) {
  print "    | `'$word'`   <!-- ", join(' ',@{$words{$word}}), " -->\n\n";
}
